{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/utils/utils.js","webpack:///./src/drawings/waves.js","webpack:///./src/drawings/sand.js","webpack:///./src/drawings/bezier_jokes.js","webpack:///./src/drawings/bezier_jokes_v2.js","webpack:///./src/drawings/random_symmetry.js","webpack:///./src/background.js","webpack:///./src/drawings/circles.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","FULL_PI","Math","PI","throttle","type","obj","window","running","addEventListener","requestAnimationFrame","dispatchEvent","CustomEvent","REPEAT_COUNT_INFINITY","animate","options","animation","keepAnimating","start","performance","now","time","timeFraction","duration","progress","timing","draw","restart","repeatCount","prevTiming","repeat","drawFunc","id","setInterval","clearInterval","animateBetween","a","b","u","Point","x","y","this","parseFloat","toFixed","other","ctx","moveTo","lineTo","hypot","k","center","radius","dist","angleBetweenTwoDots","first","second","atan2","toDegrees","rad","polarToX","theta","cos","polarToY","sin","smallestRotateDirection","current","newAngle","aR","clampToRadius","actualPoint","offset","sub","distance","len","direction","div","add","mult","getTextSize","text","font","context","canvas","document","createElement","getContext","metrics","measureText","width","createCirclePoints","startAngle","amount","step","currentAngle","steps","push","tweak","random","binom","coeff","bezier","plist","order","length","pow","drawAsSpline","points","beginPath","xm","ym","quadraticCurveTo","end","stroke","MAX_RADIUS_WAVES","INIT_RADIUS_WAVES","calculateWaveR","nodeCount","amplitude","drawWave","offsetPoint","increase","counter","SAND_RADIUS","prevDelta","prevAngle","POINTS_AMOUNT","drawBezier","fillStyle","map","point","arc","fill","randomTweaksV2V1","tweaks","connections","Grid","size","nodes","mirrornodes","connectChoices","Array","connect","save","rotate","connectDraw","restore","animations","launchWaves","lastAnimation","abs","fraction","waveOffset","clearRect","height","currentRadius","distanceFromCenter","strokeStyle","drawCircleWaves","launchSand","min","newR","drawSand","launchCircles","floor","grd","isInside","createRadialGradient","alpha","cosAlphaR","sinAlphaR","createLinearGradient","addColorStop","drawCircles","launchBezier","launchBezierV2","tweakFunc","setLineDash","lineJoin","lineWidth","drawBezierV2","SPACE_Y","SPACE_X","FIT_AMOUNT_X","FIT_AMOUNT_Y","fitX","fitY","spaceX","spaceY","gridSize","fullGridSize","j","translate","display","drawSymmetry","getElementById","body","getElementsByTagName","resizeCanvas","innerWidth","innerHeight","clientWidth","clientHeight"],"mappings":"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","file":"bg.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","export const FULL_PI = Math.PI * 2;\n\nexport function throttle(type, name, obj) {\n    obj = obj || window;\n    let running = false;\n    let func = () => {\n        if (running) {\n            return;\n        }\n        running = true;\n        requestAnimationFrame(() => {\n            obj.dispatchEvent(new CustomEvent(name));\n            running = false;\n        });\n    };\n    obj.addEventListener(type, func);\n}\n\nexport const REPEAT_COUNT_INVERSE = -1;\nexport const REPEAT_COUNT_INFINITY = -2;\n\n/**\n *\n * @param options\n *        - duration\n *        - timing convert time to progress\n *        - draw\n *        - repeatCount\n * @returns {{keepAnimating: boolean}} set keepAnimating to false, if you want to stop animation\n */\nexport function animate(options) {\n\n    let animation = {\n        keepAnimating: true,\n    };\n\n    let start = performance.now();\n    requestAnimationFrame(function animate(time) {\n\n        let timeFraction = (time - start) / options.duration;\n        if (timeFraction > 1) timeFraction = 1;\n        if (timeFraction < 0) timeFraction = 0;\n\n        let progress = options.timing(timeFraction);\n\n        options.draw(progress);\n\n        if (animation.keepAnimating) {\n            if (timeFraction < 1) {\n                requestAnimationFrame(animate);\n            } else {\n                let restart = true;\n                if (options.repeatCount === REPEAT_COUNT_INVERSE) {\n                    let prevTiming = options.timing;\n                    options.timing = t => prevTiming(1 - t);\n                    options.repeatCount = 0;\n                } else if (options.repeatCount === REPEAT_COUNT_INFINITY) {\n\n                } else if (options.repeatCount > 0) {\n                    options.repeatCount--;\n                } else {\n                    restart = false;\n                }\n\n                if (restart) {\n                    start = performance.now();\n                    requestAnimationFrame(animate);\n                }\n            }\n        }\n    });\n\n    return animation;\n}\n\nexport function repeat(drawFunc, repeat) {\n    let animation = {\n        keepAnimating: true\n    };\n    let id = setInterval(() => {\n        if (!animation.keepAnimating) {\n            clearInterval(id);\n        } else {\n            requestAnimationFrame(drawFunc);\n        }\n    }, repeat);\n\n    return animation;\n}\n\nexport function animateBetween(a, b, u) {\n    return (1 - u) * a + u * b;\n}\n\nexport class Point {\n\n    constructor(x, y) {\n        this.x = parseFloat(x.toFixed(4));\n        this.y = parseFloat(y.toFixed(4));\n    }\n\n    connect(other, ctx) {\n        ctx.moveTo(this.x, this.y);\n        ctx.lineTo(other.x, other.y);\n    }\n\n    add(other) {\n        return new Point(this.x + other.x, this.y + other.y);\n    }\n\n    sub(other) {\n        return new Point(this.x - other.x, this.y - other.y);\n    }\n\n    dist(other) {\n        return Math.hypot(this.x - other.x, this.y - other.y);\n    }\n\n    len() {\n        return Math.hypot(this.x, this.y);\n    }\n\n    mult(k) {\n        return new Point(this.x * k, this.y * k);\n    }\n\n    div(k) {\n        return new Point(this.x / k, this.y / k);\n    }\n\n    isInside(center, radius) {\n        return this.dist(center) <= radius;\n    }\n}\n\nexport function angleBetweenTwoDots(first, second) {\n    return Math.atan2(second.y - first.y, second.x - first.x);\n}\n\nexport function toDegrees(rad) {\n    return rad * (180 / Math.PI);\n}\n\nexport function toRadians(angle) {\n    return angle * (Math.PI / 180);\n}\n\nexport function polarToX(r, theta) {\n    return r * Math.cos(theta);\n}\n\nexport function polarToY(r, theta) {\n    return r * Math.sin(theta);\n}\n\nexport function smallestRotateDirection(current, newAngle) {\n    let aR;\n    current = current || 0; // if rot undefined or 0, make 0, else rot\n    aR = current % 360;\n    if (aR < 0) {\n        aR += 360;\n    }\n    if (aR < 180 && (newAngle > (aR + 180))) {\n        current -= 360;\n    }\n    if (aR >= 180 && (newAngle <= (aR - 180))) {\n        current += 360;\n    }\n    current += (newAngle - aR);\n\n    return current;\n}\n\nexport function clampToRadius(center, actualPoint, radius) {\n    let offset = actualPoint.sub(center);\n    let distance = offset.len();\n\n    if (distance < radius) {\n        return actualPoint;\n    } else {\n        let direction = offset.div(distance);\n        return center.add(direction.mult(radius));\n    }\n}\n\nexport function clamp(val, min, max) {\n    if (val <= min) {\n        return min;\n    } else if (val >= max) {\n        return max;\n    } else {\n        return val;\n    }\n}\n\nexport function getTextSize(text, font) {\n    // re-use canvas object for better performance\n    let canvas = getTextSize.canvas || (getTextSize.canvas = document.createElement(\"canvas\"));\n    let context = canvas.getContext(\"2d\");\n    context.font = font;\n    let metrics = context.measureText(text);\n\n    return new Point(metrics.width, 32);\n}\n\nexport function createCirclePoints(radius, startAngle, amount) {\n    let step = FULL_PI / amount;\n    let currentAngle = startAngle;\n    let steps = [];\n    for (let i = 0; i < amount; i++) {\n        steps.push(new Point(polarToX(radius, currentAngle), polarToY(radius, currentAngle)));\n        currentAngle += step;\n    }\n\n    return steps;\n}\n\nexport function tweak(k) {\n    return k * (-1 + Math.random() * 2)\n}\n\nexport function getRnd(n, min, max) {\n    let res = [];\n    for (let i = 0; i < n; i++) {\n        res.push(min + Math.random() * (max - min));\n    }\n    return res\n}\n\nexport function getRndSign(n) {\n    let res = [];\n    for (let i = 0; i < n; i++) {\n        Math.random() >= 0.5 ? res.push(-1) : res.push(1);\n    }\n    return res\n}\n\n// bezier code from: https://stackoverflow.com/a/31169371/4142087\n\n// from: http://rosettacode.org/wiki/Evaluate_binomial_coefficients#JavaScript\nexport function binom(n, k) {\n    let coeff = 1;\n    for (let i = n - k + 1; i <= n; i++) coeff *= i;\n    for (let i = 1; i <= k; i++) coeff /= i;\n    return coeff;\n}\n\n// based on: https://stackoverflow.com/questions/16227300\nexport function bezier(t, plist) {\n    let order = plist.length - 1;\n\n    let y = 0;\n    let x = 0;\n\n    for (let i = 0; i <= order; i++) {\n        x = x + (binom(order, i) * Math.pow((1 - t), (order - i)) * Math.pow(t, i) * (plist[i].x));\n        y = y + (binom(order, i) * Math.pow((1 - t), (order - i)) * Math.pow(t, i) * (plist[i].y));\n    }\n\n    return {x, y};\n}\n\n// based on incovergent impl, but I think he took it from stackoverflow (I saw it there :) )\nexport function drawAsSpline(ctx, points) {\n    ctx.beginPath();\n    ctx.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length - 2; i++) {\n        let xm = (points[i].x + points[i + 1].x) / 2\n            , ym = (points[i].y + points[i + 1].y) / 2;\n        ctx.quadraticCurveTo(points[i].x, points[i].y, xm, ym);\n    }\n    let end = points.length - 2;\n    ctx.quadraticCurveTo(points[end].x, points[end].y, points[end + 1].x, points[end + 1].y);\n    ctx.stroke();\n}","import {animate, animateBetween, polarToX, polarToY, REPEAT_COUNT_INFINITY} from \"../utils/utils\";\n\nlet MAX_RADIUS_WAVES = 0;\nlet INIT_RADIUS_WAVES = 0;\nconst WAVE_GAP = 100;\nconst WAVE_AMPLITUDE = 30;\n\nfunction drawCircleWaves(ctx, options, waveOffset) {\n    ctx.clearRect(0, 0, options.width, options.height);\n\n    let currentRadius = INIT_RADIUS_WAVES + waveOffset;\n\n    while (currentRadius < MAX_RADIUS_WAVES) {\n\n        let distanceFromCenter = currentRadius / MAX_RADIUS_WAVES;\n\n        ctx.strokeStyle = 'rgba(0,0,0,' + distanceFromCenter + ')';\n\n        drawWave(ctx, currentRadius, options.center, WAVE_AMPLITUDE * distanceFromCenter);\n\n        currentRadius += WAVE_GAP;\n    }\n}\n\nfunction calculateWaveR(offset, theta, nodeCount, amplitude) {\n    return offset + amplitude * Math.sin(nodeCount * theta);\n}\n\nfunction drawWave(ctx, radius, offsetPoint, amplitude) {\n    let increase = Math.PI / (180 * 1);\n\n    let counter = 0;\n    let x = polarToX(calculateWaveR(radius, counter, 10, amplitude), counter) + offsetPoint.x;\n    let y = polarToY(calculateWaveR(radius, counter, 10, amplitude), counter) + offsetPoint.y;\n\n    ctx.beginPath();\n    while (counter < 2 * Math.PI) {\n\n        ctx.moveTo(x, y);\n\n        x = polarToX(calculateWaveR(radius, counter, 10, amplitude), counter) + offsetPoint.x;\n        y = polarToY(calculateWaveR(radius, counter, 10, amplitude), counter) + offsetPoint.y;\n\n        counter += increase;\n\n        ctx.lineTo(x, y);\n    }\n    ctx.stroke();\n}\n\nexport function launchWaves(ctx, options) {\n\n    let radius = options.center.len();\n\n    MAX_RADIUS_WAVES = radius;\n    INIT_RADIUS_WAVES = radius / WAVE_GAP;\n\n    if (launchWaves.lastAnimation) {\n        launchWaves.lastAnimation.keepAnimating = false;\n    }\n    launchWaves.lastAnimation = animate({\n        duration: 5000.0,\n        timing: t => animateBetween(0, WAVE_GAP, Math.abs(t)),\n        draw: fraction => {\n            drawCircleWaves(ctx, options, fraction);\n        },\n        repeatCount: REPEAT_COUNT_INFINITY,\n    });\n}\n\n","import {FULL_PI, polarToX, polarToY, repeat} from \"../utils/utils\";\n\nlet SAND_RADIUS = 0;\nconst ANGLE_STEP = Math.PI / (180 * 4);\nconst STEP_AMOUNT = 100;\n\nlet prevDelta = 0;\nlet prevAngle = 0;\n\nfunction drawSand(ctx, options) {\n\n    ctx.fillStyle = \"rgba(0,0,0,0.05)\";\n\n    for (let i = 0; i < STEP_AMOUNT; i++) {\n        ctx.beginPath();\n\n        prevDelta = prevDelta + (-1 + Math.random() * 2);\n\n        let newR = SAND_RADIUS + prevDelta;\n\n        ctx.arc(\n            options.center.x + polarToX(newR, prevAngle),\n            options.center.y + polarToY(newR, prevAngle),\n            1, 0, FULL_PI);\n        ctx.fill();\n\n        prevAngle += (1 / newR);\n    }\n}\n\nexport function launchSand(ctx, options) {\n\n    SAND_RADIUS = Math.min(options.height, options.width) * 0.4;\n\n    if (launchSand.lastAnimation) {\n        launchSand.lastAnimation.keepAnimating = false;\n    }\n\n    launchSand.lastAnimation = repeat(\n        () => {\n            drawSand(ctx, options);\n        }, 16\n    );\n}\n","import {bezier, createCirclePoints, FULL_PI, Point, repeat, tweak} from \"../utils/utils\";\n\nconst RADIUS = 200;\nconst POINTS_AMOUNT = Math.random() * 30 + 50;//25;\n\n// simple\nfunction randomTweaksV1(points) {\n    return points.map(p => p.add(\n        new Point(\n            tweak(20),\n            tweak(20)\n        )));\n}\n\nlet points = createCirclePoints(RADIUS, Math.random() * FULL_PI, POINTS_AMOUNT);\n\nfunction drawBezier(ctx, options) {\n\n    ctx.fillStyle = \"rgba(0,0,0,0.05)\";\n\n    points = randomTweaksV1(points);\n\n    for (let i = 0; i < 1; i += (Math.random() * 0.006 + 0.001)) {\n\n        ctx.beginPath();\n\n        let point = bezier(i, points);\n\n        ctx.arc(\n            options.center.x + point.x,\n            options.center.y + point.y,\n            1, 0, FULL_PI);\n        ctx.fill();\n    }\n}\n\nexport function launchBezier(ctx, options) {\n\n    if (launchBezier.lastAnimation) {\n        launchBezier.lastAnimation.keepAnimating = false;\n    }\n\n    launchBezier.lastAnimation = repeat(\n        () => {\n            drawBezier(ctx, options);\n        }, 100\n    );\n}\n\n","import {createCirclePoints, drawAsSpline, FULL_PI, Point, repeat, tweak} from \"../utils/utils\";\n\nconst RADIUS = 200;\nconst POINTS_AMOUNT = Math.random() * 30 + 25;\n\n// simple\nfunction randomTweaksV2V1(points) {\n    return points.map(p => p.add(\n        new Point(\n            tweak(3),\n            tweak(3)\n        )));\n}\n\n// idx matters\nfunction randomTweaksV2V2(points) {\n    // not now, invent something better later\n    return randomTweaksV2V1(points);\n    // return points.map(function (p, idx, arr) {\n    //     return p.add(\n    //         new Point(\n    //             tweak(5 * idx / arr.length),\n    //             tweak(5 * idx / arr.length)\n    //         ));\n    // });\n}\n\nconst tweaks = [randomTweaksV2V1, randomTweaksV2V2];\n\nlet points = createCirclePoints(RADIUS, Math.random() * FULL_PI, POINTS_AMOUNT);\n\nfunction drawBezierV2(ctx, options, tweakFunc) {\n\n    ctx.setLineDash([1, 1 + 6 * Math.random()]);\n    ctx.fillStyle = \"rgba(0,0,0,0.05)\";\n    ctx.strokeStyle = \"rgba(0,0,0,0.05)\";\n    ctx.lineJoin = \"round\";\n    ctx.lineWidth = 1;\n\n    points = tweakFunc(points);\n\n    drawAsSpline(ctx, points.map(p => p.add(options.center)));\n}\n\nexport function launchBezierV2(ctx, options) {\n\n    if (launchBezierV2.lastAnimation) {\n        launchBezierV2.lastAnimation.keepAnimating = false;\n    }\n\n    let tweakFunc = tweaks[Math.floor(Math.random() * tweaks.length)];\n\n    launchBezierV2.lastAnimation = repeat(\n        () => {\n            drawBezierV2(ctx, options, tweakFunc);\n        }, 16\n    );\n}\n\n","// list for connections between nodes\nimport {Point} from \"../utils/utils\";\n\nconst connections = [[0, 1], [0, 3],\n    [1, 2], [1, 3], [1, 4],\n    [2, 4], [2, 6],\n    [3, 4], [3, 5],\n    [4, 5], [4, 6],\n    [5, 6], [5, 7],\n    [6, 7], [6, 8],\n    [7, 8]];\n\n\nclass Grid {\n    constructor(size) {\n\n        this.nodes = [];\n        this.mirrornodes = [];\n\n        // create the nodes in the grid\n        this.nodes.push(new Point(0, 0));\n        this.nodes.push(new Point(0, -size));\n        this.nodes.push(new Point(0, -2 * size));\n        this.nodes.push(new Point(size / 2.0, -size / 2.0));\n        this.nodes.push(new Point(0.5 * size, -1.5 * size));\n        this.nodes.push(new Point(size, -size));\n        this.nodes.push(new Point(size, -2 * size));\n        this.nodes.push(new Point(1.5 * size, -1.5 * size));\n        this.nodes.push(new Point(2 * size, -2 * size));\n\n        // create the nodes which mirror over the diagonal line\n        this.mirrornodes.push(new Point(0, 0));\n        this.mirrornodes.push(new Point(size, 0));\n        this.mirrornodes.push(new Point(2 * size, 0));\n        this.mirrornodes.push(new Point(size / 2.0, -size / 2.0));\n        this.mirrornodes.push(new Point(1.5 * size, -0.5 * size));\n        this.mirrornodes.push(new Point(size, -size));\n        this.mirrornodes.push(new Point(2 * size, -size));\n        this.mirrornodes.push(new Point(1.5 * size, -1.5 * size));\n        this.mirrornodes.push(new Point(2 * size, -2 * size));\n\n        // randomly choose which nodes are connecting\n        this.connectChoices = new Array(16);\n        for (let i = 0; i < this.connectChoices.length; i++) {\n            this.connectChoices[i] = Math.random() >= 0.5;\n        }\n    }\n\n    connectDraw(ctx) {\n        for (let i = 0; i < this.connectChoices.length; i++) {\n            if (this.connectChoices[i]) {\n                this.nodes[connections[i][0]].connect(this.nodes[connections[i][1]], ctx);\n                this.mirrornodes[connections[i][0]].connect(this.mirrornodes[connections[i][1]], ctx);\n            }\n        }\n    }\n\n    display(ctx) {\n\n        for (let i = 0; i < 4; i++) {\n            ctx.save();\n            ctx.rotate((Math.PI / 2) * i);\n            this.connectDraw(ctx);\n            ctx.restore();\n        }\n    }\n}\n\nfunction drawSymmetry(ctx, options, fitX, fitY, spaceX, spaceY, gridSize, fullGridSize) {\n\n    ctx.beginPath();\n    for (let i = 0; i < fitX; i++) {\n        for (let j = 0; j < fitY; j++) {\n            ctx.save();\n            ctx.translate(i * (spaceX + fullGridSize), j * (spaceY + fullGridSize));\n            new Grid(gridSize).display(ctx);\n            ctx.restore();\n        }\n    }\n    ctx.stroke();\n}\n\nexport function launchRandomSymmetryArt(ctx, options) {\n\n    const GRID_SIZE = 10;\n    const FULL_GRID_SIZE = 3 * GRID_SIZE;\n    let SPACE_Y = 50;\n    let SPACE_X = 50;\n\n    const FIT_AMOUNT_X = Math.floor(options.width / (FULL_GRID_SIZE + SPACE_X) + 1);\n    const FIT_AMOUNT_Y = Math.floor(options.height / (FULL_GRID_SIZE + SPACE_Y) + 1);\n\n    SPACE_X = options.width / (FIT_AMOUNT_X - 1) - FULL_GRID_SIZE;\n    SPACE_Y = options.height / (FIT_AMOUNT_Y - 1) - FULL_GRID_SIZE;\n\n    ctx.strokeStyle = 'rgba(0,0,0,0.5)';\n\n    ctx.clearRect(0, 0, options.width, options.height);\n    drawSymmetry(ctx, options, FIT_AMOUNT_X, FIT_AMOUNT_Y, SPACE_X, SPACE_Y, GRID_SIZE, FULL_GRID_SIZE);\n}","import {Point} from \"./utils/utils\";\nimport {launchWaves} from \"./drawings/waves\";\nimport {launchSand} from \"./drawings/sand\";\nimport {launchCircles} from \"./drawings/circles\";\nimport {launchBezier} from \"./drawings/bezier_jokes\";\nimport {launchBezierV2} from \"./drawings/bezier_jokes_v2\";\nimport {launchRandomSymmetryArt} from \"./drawings/random_symmetry\";\n\nconst animations = [\n    launchWaves, // credits to https://medium.com/s23nyc-tech/geometric-android-animations-using-the-canvas-dd687c43f3f4\n    launchSand, // credits to incovergent\n    launchCircles,\n    launchBezier,\n    launchBezierV2, // credits to incovergent\n    launchRandomSymmetryArt // credits to atticusbones\n];\n\nconst center = new Point(0, 0);\n\nwindow.addEventListener('load', () => {\n\n    let canvas = document.getElementById('bg-canvas');\n    let ctx = canvas.getContext('2d');\n\n    let body = document.getElementsByTagName('body')[0];\n\n    let animation = animations[Math.floor(Math.random() * animations.length)];\n\n    function resizeCanvas() {\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n\n        center.x = body.clientWidth * 0.5;\n        center.y = body.clientHeight * 0.5;\n\n        animation(ctx, {\n            center: center,\n            height: canvas.height,\n            width: canvas.width\n        });\n    }\n\n    resizeCanvas();\n\n    window.addEventListener('optimizedResize', () => {\n        resizeCanvas();\n    });\n});\n\n","import {angleBetweenTwoDots, FULL_PI, Point, repeat} from \"../utils/utils\";\n\nconst CIRCLE_RADIUS = 5;\nconst CIRCLES_BY_STEP = 1;\n\nfunction drawCircles(ctx, options) {\n\n    for (let i = 0; i < CIRCLES_BY_STEP; i++) {\n\n        let point = new Point(Math.random() * options.width, Math.random() * options.height);\n        let radius = Math.floor(Math.random() * 50) + CIRCLE_RADIUS;\n\n        let grd;\n        if (options.center.isInside(point, radius)) {\n            grd = ctx.createRadialGradient(\n                options.center.x,\n                options.center.y,\n                1,\n                point.x,\n                point.y,\n                radius\n            );\n        } else {\n            let alpha = angleBetweenTwoDots(point, options.center);\n            let cosAlphaR = Math.cos(alpha) * radius;\n            let sinAlphaR = Math.sin(alpha) * radius;\n\n            grd = ctx.createLinearGradient(\n                point.x + cosAlphaR,\n                point.y + sinAlphaR,\n                point.x - cosAlphaR,\n                point.y - sinAlphaR\n            );\n        }\n\n        grd.addColorStop(0, 'rgba(0,0,0,0.05)');\n        grd.addColorStop(1, 'rgba(0,0,0,0)');\n\n        ctx.fillStyle = grd;\n\n        ctx.beginPath();\n\n        ctx.arc(\n            point.x,\n            point.y,\n            radius, 0, FULL_PI);\n        ctx.fill();\n    }\n}\n\n// todo: improve\nfunction drawCirclesV2(ctx, options) {\n\n    for (let i = 0; i < CIRCLES_BY_STEP; i++) {\n\n        let point = new Point(Math.random() * options.width, Math.random() * options.height);\n        let radius = Math.floor(Math.random() * 50) + CIRCLE_RADIUS;\n\n        let grd = ctx.createRadialGradient(\n            options.center.x,\n            options.center.y,\n            1,\n            options.center.x,\n            options.center.y,\n            options.center.len()\n        );\n\n        grd.addColorStop(0, 'rgba(0,0,0,0.05)');\n        grd.addColorStop(1, 'rgba(0,0,0,0)');\n\n        ctx.fillStyle = grd;\n\n        ctx.beginPath();\n\n        ctx.arc(\n            point.x,\n            point.y,\n            radius, 0, FULL_PI);\n        ctx.fill();\n    }\n}\n\nexport function launchCircles(ctx, options) {\n\n    if (launchCircles.lastAnimation) {\n        launchCircles.lastAnimation.keepAnimating = false;\n    }\n\n    launchCircles.lastAnimation = repeat(\n        () => {\n            drawCircles(ctx, options);\n        }, 25\n    );\n}\n\n"],"sourceRoot":""}