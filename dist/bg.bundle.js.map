{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/utils/utils.js","webpack:///./src/drawings/waves.js","webpack:///./src/drawings/sand.js","webpack:///./src/drawings/circles.js","webpack:///./src/drawings/bezier_jokes.js","webpack:///./src/drawings/bezier_jokes_v2.js","webpack:///./src/drawings/random_symmetry.js","webpack:///./src/background.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","FULL_PI","Math","PI","throttle","type","obj","window","running","addEventListener","requestAnimationFrame","dispatchEvent","CustomEvent","REPEAT_COUNT_INVERSE","REPEAT_COUNT_INFINITY","animate","options","animation","keepAnimating","start","performance","now","time","timeFraction","duration","progress","timing","draw","restart","repeatCount","prevTiming","repeat","drawFunc","id","setInterval","clearInterval","animateBetween","a","b","u","Point","x","y","this","parseFloat","toFixed","other","ctx","moveTo","lineTo","hypot","k","center","radius","dist","angleBetweenTwoDots","first","second","atan2","toDegrees","rad","polarToX","theta","cos","polarToY","sin","smallestRotateDirection","current","newAngle","aR","clampToRadius","actualPoint","offset","sub","distance","len","direction","div","add","mult","getTextSize","text","font","context","canvas","document","createElement","getContext","metrics","measureText","width","createCirclePoints","startAngle","amount","step","currentAngle","steps","push","tweak","random","binom","coeff","bezier","plist","order","length","pow","drawAsSpline","points","beginPath","xm","ym","quadraticCurveTo","end","stroke","MAX_RADIUS_WAVES","INIT_RADIUS_WAVES","WAVE_GAP","WAVE_AMPLITUDE","calculateWaveR","nodeCount","amplitude","drawWave","offsetPoint","increase","counter","SAND_RADIUS","STEP_AMOUNT","prevDelta","prevAngle","CIRCLE_RADIUS","CIRCLES_BY_STEP","POINTS_AMOUNT","drawBezier","fillStyle","map","point","arc","fill","randomTweaksV2V1","tweaks","connections","Grid","size","nodes","mirrornodes","connectChoices","Array","connect","save","rotate","connectDraw","restore","animations","launchWaves","lastAnimation","abs","fraction","waveOffset","clearRect","height","currentRadius","distanceFromCenter","strokeStyle","drawCircleWaves","launchSand","min","newR","drawSand","launchCircles","floor","grd","isInside","createRadialGradient","alpha","cosAlphaR","sinAlphaR","createLinearGradient","addColorStop","drawCircles","launchBezier","launchBezierV2","tweakFunc","setLineDash","lineJoin","lineWidth","drawBezierV2","SPACE_Y","SPACE_X","FIT_AMOUNT_X","FIT_AMOUNT_Y","fitX","fitY","spaceX","spaceY","gridSize","fullGridSize","j","translate","display","drawSymmetry","getElementById","body","getElementsByTagName","resizeCanvas","innerWidth","innerHeight","clientWidth","clientHeight"],"mappings":"aACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,G,2yBClF9C,IAAMC,EAAoB,EAAVC,KAAKC,GAErB,SAASC,EAASC,EAAM7B,EAAM8B,GACjCA,EAAMA,GAAOC,OACb,IAAIC,GAAU,EAWdF,EAAIG,iBAAiBJ,GAVV,WACHG,IAGJA,GAAU,EACVE,uBAAsB,WAClBJ,EAAIK,cAAc,IAAIC,YAAYpC,IAClCgC,GAAU,SAMf,IAAMK,GAAwB,EACxBC,GAAyB,EAE/B,SAASC,EAAQC,GAEpB,IAAIC,EAAY,CACZC,eAAe,GAGfC,EAAQC,YAAYC,MAoCxB,OAnCAX,uBAAsB,SAASK,EAAQO,GAEnC,IAAIC,GAAgBD,EAAOH,GAASH,EAAQQ,SACxCD,EAAe,IAAGA,EAAe,GACjCA,EAAe,IAAGA,EAAe,GAErC,IAAIE,EAAWT,EAAQU,OAAOH,GAI9B,GAFAP,EAAQW,KAAKF,GAETR,EAAUC,cACV,GAAIK,EAAe,EACfb,sBAAsBK,OACnB,CACH,IAAIa,GAAU,EACd,GAAIZ,EAAQa,cAAgBhB,EAAsB,CAC9C,IAAIiB,EAAad,EAAQU,OACzBV,EAAQU,OAAS,SAAAvC,GAAC,OAAI2C,EAAW,EAAI3C,IACrC6B,EAAQa,YAAc,OACfb,EAAQa,cAAgBf,IAExBE,EAAQa,YAAc,EAC7Bb,EAAQa,cAERD,GAAU,GAGVA,IACAT,EAAQC,YAAYC,MACpBX,sBAAsBK,QAM/BE,EAGJ,SAASc,EAAOC,EAAUD,GAC7B,IAAId,EAAY,CACZC,eAAe,GAEfe,EAAKC,aAAY,WACZjB,EAAUC,cAGXR,sBAAsBsB,GAFtBG,cAAcF,KAInBF,GAEH,OAAOd,EAGJ,SAASmB,EAAeC,EAAGC,EAAGC,GACjC,OAAQ,EAAIA,GAAKF,EAAIE,EAAID,EAGtB,IAAME,EAAb,WAEI,WAAYC,EAAGC,I,4FAAG,SACdC,KAAKF,EAAIG,WAAWH,EAAEI,QAAQ,IAC9BF,KAAKD,EAAIE,WAAWF,EAAEG,QAAQ,I,UAJtC,O,EAAA,G,EAAA,+BAOYC,EAAOC,GACXA,EAAIC,OAAOL,KAAKF,EAAGE,KAAKD,GACxBK,EAAIE,OAAOH,EAAML,EAAGK,EAAMJ,KATlC,0BAYQI,GACA,OAAO,IAAIN,EAAMG,KAAKF,EAAIK,EAAML,EAAGE,KAAKD,EAAII,EAAMJ,KAb1D,0BAgBQI,GACA,OAAO,IAAIN,EAAMG,KAAKF,EAAIK,EAAML,EAAGE,KAAKD,EAAII,EAAMJ,KAjB1D,2BAoBSI,GACD,OAAO5C,KAAKgD,MAAMP,KAAKF,EAAIK,EAAML,EAAGE,KAAKD,EAAII,EAAMJ,KArB3D,4BAyBQ,OAAOxC,KAAKgD,MAAMP,KAAKF,EAAGE,KAAKD,KAzBvC,2BA4BSS,GACD,OAAO,IAAIX,EAAMG,KAAKF,EAAIU,EAAGR,KAAKD,EAAIS,KA7B9C,0BAgCQA,GACA,OAAO,IAAIX,EAAMG,KAAKF,EAAIU,EAAGR,KAAKD,EAAIS,KAjC9C,+BAoCaC,EAAQC,GACb,OAAOV,KAAKW,KAAKF,IAAWC,O,2BArCpC,KAyCO,SAASE,EAAoBC,EAAOC,GACvC,OAAOvD,KAAKwD,MAAMD,EAAOf,EAAIc,EAAMd,EAAGe,EAAOhB,EAAIe,EAAMf,GAGpD,SAASkB,EAAUC,GACtB,OAAOA,GAAO,IAAM1D,KAAKC,IAOtB,SAAS0D,EAAS9E,EAAG+E,GACxB,OAAO/E,EAAImB,KAAK6D,IAAID,GAGjB,SAASE,EAASjF,EAAG+E,GACxB,OAAO/E,EAAImB,KAAK+D,IAAIH,GAGjB,SAASI,EAAwBC,EAASC,GAC7C,IAAIC,EAcJ,OAZAA,GADAF,EAAUA,GAAW,GACN,KACN,IACLE,GAAM,KAENA,EAAK,KAAQD,EAAYC,EAAK,MAC9BF,GAAW,KAEXE,GAAM,KAAQD,GAAaC,EAAK,MAChCF,GAAW,KAEfA,GAAYC,EAAWC,EAKpB,SAASC,EAAclB,EAAQmB,EAAalB,GAC/C,IAAImB,EAASD,EAAYE,IAAIrB,GACzBsB,EAAWF,EAAOG,MAEtB,GAAID,EAAWrB,EACX,OAAOkB,EAEP,IAAIK,EAAYJ,EAAOK,IAAIH,GAC3B,OAAOtB,EAAO0B,IAAIF,EAAUG,KAAK1B,IAclC,SAAS2B,EAAYC,EAAMC,GAE9B,IACIC,GADSH,EAAYI,SAAWJ,EAAYI,OAASC,SAASC,cAAc,YAC3DC,WAAW,MAChCJ,EAAQD,KAAOA,EACf,IAAIM,EAAUL,EAAQM,YAAYR,GAElC,OAAO,IAAIzC,EAAMgD,EAAQE,MAAO,IAG7B,SAASC,EAAmBtC,EAAQuC,EAAYC,GAInD,IAHA,IAAIC,EAAO7F,EAAU4F,EACjBE,EAAeH,EACfI,EAAQ,GACH/H,EAAI,EAAGA,EAAI4H,EAAQ5H,IACxB+H,EAAMC,KAAK,IAAIzD,EAAMqB,EAASR,EAAQ0C,GAAe/B,EAASX,EAAQ0C,KACtEA,GAAgBD,EAGpB,OAAOE,EAGJ,SAASE,EAAM/C,GAClB,OAAOA,GAA0B,EAAhBjD,KAAKiG,SAAT,GAsBV,SAASC,EAAM1G,EAAGyD,GAErB,IADA,IAAIkD,EAAQ,EACHpI,EAAIyB,EAAIyD,EAAI,EAAGlF,GAAKyB,EAAGzB,IAAKoI,GAASpI,EAC9C,IAAK,IAAIA,EAAI,EAAGA,GAAKkF,EAAGlF,IAAKoI,GAASpI,EACtC,OAAOoI,EAIJ,SAASC,EAAOnH,EAAGoH,GAMtB,IALA,IAAIC,EAAQD,EAAME,OAAS,EAEvB/D,EAAI,EACJD,EAAI,EAECxE,EAAI,EAAGA,GAAKuI,EAAOvI,IACxBwE,GAAS2D,EAAMI,EAAOvI,GAAKiC,KAAKwG,IAAK,EAAIvH,EAAKqH,EAAQvI,GAAMiC,KAAKwG,IAAIvH,EAAGlB,GAAMsI,EAAMtI,GAAGwE,EACvFC,GAAS0D,EAAMI,EAAOvI,GAAKiC,KAAKwG,IAAK,EAAIvH,EAAKqH,EAAQvI,GAAMiC,KAAKwG,IAAIvH,EAAGlB,GAAMsI,EAAMtI,GAAGyE,EAG3F,MAAO,CAACD,IAAGC,KAIR,SAASiE,EAAa5D,EAAK6D,GAC9B7D,EAAI8D,YACJ9D,EAAIC,OAAO4D,EAAO,GAAGnE,EAAGmE,EAAO,GAAGlE,GAClC,IAAK,IAAIzE,EAAI,EAAGA,EAAI2I,EAAOH,OAAS,EAAGxI,IAAK,CACxC,IAAI6I,GAAMF,EAAO3I,GAAGwE,EAAImE,EAAO3I,EAAI,GAAGwE,GAAK,EACrCsE,GAAMH,EAAO3I,GAAGyE,EAAIkE,EAAO3I,EAAI,GAAGyE,GAAK,EAC7CK,EAAIiE,iBAAiBJ,EAAO3I,GAAGwE,EAAGmE,EAAO3I,GAAGyE,EAAGoE,EAAIC,GAEvD,IAAIE,EAAML,EAAOH,OAAS,EAC1B1D,EAAIiE,iBAAiBJ,EAAOK,GAAKxE,EAAGmE,EAAOK,GAAKvE,EAAGkE,EAAOK,EAAM,GAAGxE,EAAGmE,EAAOK,EAAM,GAAGvE,GACtFK,EAAImE,W,iDCtQJC,EAAmB,EACnBC,EAAoB,EAClBC,EAAW,IACXC,EAAiB,GAmBvB,SAASC,EAAe/C,EAAQV,EAAO0D,EAAWC,GAC9C,OAAOjD,EAASiD,EAAYvH,KAAK+D,IAAIuD,EAAY1D,GAGrD,SAAS4D,EAAS3E,EAAKM,EAAQsE,EAAaF,GACxC,IAAIG,EAAW1H,KAAKC,GAAL,IAEX0H,EAAU,EACVpF,EAAIoB,YAAS0D,EAAelE,EAAQwE,EAAS,GAAIJ,GAAYI,GAAWF,EAAYlF,EACpFC,EAAIsB,YAASuD,EAAelE,EAAQwE,EAAS,GAAIJ,GAAYI,GAAWF,EAAYjF,EAGxF,IADAK,EAAI8D,YACGgB,EAAU,EAAI3H,KAAKC,IAEtB4C,EAAIC,OAAOP,EAAGC,GAEdD,EAAIoB,YAAS0D,EAAelE,EAAQwE,EAAS,GAAIJ,GAAYI,GAAWF,EAAYlF,EACpFC,EAAIsB,YAASuD,EAAelE,EAAQwE,EAAS,GAAIJ,GAAYI,GAAWF,EAAYjF,EAEpFmF,GAAWD,EAEX7E,EAAIE,OAAOR,EAAGC,GAElBK,EAAImE,SC7CR,IAAIY,EAAc,EAEZC,GADa7H,KAAKC,GACJ,KAEhB6H,EAAY,EACZC,EAAY,ECLhB,IAAMC,EAAgB,EAChBC,EAAkB,ECDxB,IACMC,EAAgC,GAAhBlI,KAAKiG,SAAgB,GAW3C,IAAIS,EAASjB,YAZE,IAYyBzF,KAAKiG,SAAWlG,IAASmI,GAEjE,SAASC,EAAWtF,EAAK/B,GAErB+B,EAAIuF,UAAY,mBAEhB1B,EAAwBA,EAbV2B,KAAI,SAAAxI,GAAC,OAAIA,EAAE+E,IACrB,IAAItC,IACA0D,YAAM,IACNA,YAAM,SAYd,IAAK,IAAIjI,EAAI,EAAGA,EAAI,EAAGA,GAAsB,KAAhBiC,KAAKiG,SAAmB,KAAQ,CAEzDpD,EAAI8D,YAEJ,IAAI2B,EAAQlC,YAAOrI,EAAG2I,GAEtB7D,EAAI0F,IACAzH,EAAQoC,OAAOX,EAAI+F,EAAM/F,EACzBzB,EAAQoC,OAAOV,EAAI8F,EAAM9F,EACzB,EAAG,EAAGzC,KACV8C,EAAI2F,QC9BZ,IACMN,EAAgC,GAAhBlI,KAAKiG,SAAgB,GAG3C,SAASwC,EAAiB/B,GACtB,OAAOA,EAAO2B,KAAI,SAAAxI,GAAC,OAAIA,EAAE+E,IACrB,IAAItC,IACA0D,YAAM,GACNA,YAAM,QAiBlB,IAAM0C,EAAS,CAACD,EAZhB,SAA0B/B,GAEtB,OAAO+B,EAAiB/B,KAYxBA,EAASjB,YA3BE,IA2ByBzF,KAAKiG,SAAWlG,IAASmI,G,sKC1BjE,IAAMS,EAAc,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAC7B,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GACpB,CAAC,EAAG,GAAI,CAAC,EAAG,GACZ,CAAC,EAAG,GAAI,CAAC,EAAG,GACZ,CAAC,EAAG,GAAI,CAAC,EAAG,GACZ,CAAC,EAAG,GAAI,CAAC,EAAG,GACZ,CAAC,EAAG,GAAI,CAAC,EAAG,GACZ,CAAC,EAAG,IAGFC,E,WACF,WAAYC,I,4FAAM,SAEdpG,KAAKqG,MAAQ,GACbrG,KAAKsG,YAAc,GAGnBtG,KAAKqG,MAAM/C,KAAK,IAAIzD,IAAM,EAAG,IAC7BG,KAAKqG,MAAM/C,KAAK,IAAIzD,IAAM,GAAIuG,IAC9BpG,KAAKqG,MAAM/C,KAAK,IAAIzD,IAAM,GAAI,EAAIuG,IAClCpG,KAAKqG,MAAM/C,KAAK,IAAIzD,IAAMuG,EAAO,GAAMA,EAAO,IAC9CpG,KAAKqG,MAAM/C,KAAK,IAAIzD,IAAM,GAAMuG,GAAO,IAAMA,IAC7CpG,KAAKqG,MAAM/C,KAAK,IAAIzD,IAAMuG,GAAOA,IACjCpG,KAAKqG,MAAM/C,KAAK,IAAIzD,IAAMuG,GAAO,EAAIA,IACrCpG,KAAKqG,MAAM/C,KAAK,IAAIzD,IAAM,IAAMuG,GAAO,IAAMA,IAC7CpG,KAAKqG,MAAM/C,KAAK,IAAIzD,IAAM,EAAIuG,GAAO,EAAIA,IAGzCpG,KAAKsG,YAAYhD,KAAK,IAAIzD,IAAM,EAAG,IACnCG,KAAKsG,YAAYhD,KAAK,IAAIzD,IAAMuG,EAAM,IACtCpG,KAAKsG,YAAYhD,KAAK,IAAIzD,IAAM,EAAIuG,EAAM,IAC1CpG,KAAKsG,YAAYhD,KAAK,IAAIzD,IAAMuG,EAAO,GAAMA,EAAO,IACpDpG,KAAKsG,YAAYhD,KAAK,IAAIzD,IAAM,IAAMuG,GAAO,GAAMA,IACnDpG,KAAKsG,YAAYhD,KAAK,IAAIzD,IAAMuG,GAAOA,IACvCpG,KAAKsG,YAAYhD,KAAK,IAAIzD,IAAM,EAAIuG,GAAOA,IAC3CpG,KAAKsG,YAAYhD,KAAK,IAAIzD,IAAM,IAAMuG,GAAO,IAAMA,IACnDpG,KAAKsG,YAAYhD,KAAK,IAAIzD,IAAM,EAAIuG,GAAO,EAAIA,IAG/CpG,KAAKuG,eAAiB,IAAIC,MAAM,IAChC,IAAK,IAAIlL,EAAI,EAAGA,EAAI0E,KAAKuG,eAAezC,OAAQxI,IAC5C0E,KAAKuG,eAAejL,GAAKiC,KAAKiG,UAAY,G,2DAItCpD,GACR,IAAK,IAAI9E,EAAI,EAAGA,EAAI0E,KAAKuG,eAAezC,OAAQxI,IACxC0E,KAAKuG,eAAejL,KACpB0E,KAAKqG,MAAMH,EAAY5K,GAAG,IAAImL,QAAQzG,KAAKqG,MAAMH,EAAY5K,GAAG,IAAK8E,GACrEJ,KAAKsG,YAAYJ,EAAY5K,GAAG,IAAImL,QAAQzG,KAAKsG,YAAYJ,EAAY5K,GAAG,IAAK8E,M,8BAKrFA,GAEJ,IAAK,IAAI9E,EAAI,EAAGA,EAAI,EAAGA,IACnB8E,EAAIsG,OACJtG,EAAIuG,OAAQpJ,KAAKC,GAAK,EAAKlC,GAC3B0E,KAAK4G,YAAYxG,GACjBA,EAAIyG,e,gCCvDhB,IAAMC,EAAa,CN0CZ,SAASC,EAAY3G,EAAK/B,GAE7B,IAAIqC,EAASrC,EAAQoC,OAAOuB,MAE5BwC,EAAmB9D,EACnB+D,EAAoB/D,EAASgE,EAEzBqC,EAAYC,gBACZD,EAAYC,cAAczI,eAAgB,GAE9CwI,EAAYC,cAAgB5I,YAAQ,CAChCS,SAAU,IACVE,OAAQ,SAAAvC,GAAC,OAAIiD,YAAe,EAAGiF,EAAUnH,KAAK0J,IAAIzK,KAClDwC,KAAM,SAAAkI,IAxDd,SAAyB9G,EAAK/B,EAAS8I,GACnC/G,EAAIgH,UAAU,EAAG,EAAG/I,EAAQ0E,MAAO1E,EAAQgJ,QAI3C,IAFA,IAAIC,EAAgB7C,EAAoB0C,EAEjCG,EAAgB9C,GAAkB,CAErC,IAAI+C,EAAqBD,EAAgB9C,EAEzCpE,EAAIoH,YAAc,cAAgBD,EAAqB,IAEvDxC,EAAS3E,EAAKkH,EAAejJ,EAAQoC,OAAQkE,EAAiB4C,GAE9DD,GAAiB5C,GA4Cb+C,CAAgBrH,EAAK/B,EAAS6I,IAElChI,YAAaf,OCpCd,SAASuJ,EAAWtH,EAAK/B,GAE5B8G,EAAwD,GAA1C5H,KAAKoK,IAAItJ,EAAQgJ,OAAQhJ,EAAQ0E,OAE3C2E,EAAWV,gBACXU,EAAWV,cAAczI,eAAgB,GAG7CmJ,EAAWV,cAAgB5H,aACvB,YA9BR,SAAkBgB,EAAK/B,GAEnB+B,EAAIuF,UAAY,mBAEhB,IAAK,IAAIrK,EAAI,EAAGA,EAAI8J,EAAa9J,IAAK,CAClC8E,EAAI8D,YAEJmB,GAA8C,EAAhB9H,KAAKiG,SAAT,EAE1B,IAAIoE,EAAOzC,EAAcE,EAEzBjF,EAAI0F,IACAzH,EAAQoC,OAAOX,EAAIoB,YAAS0G,EAAMtC,GAClCjH,EAAQoC,OAAOV,EAAIsB,YAASuG,EAAMtC,GAClC,EAAG,EAAGhI,KACV8C,EAAI2F,OAEJT,GAAc,EAAIsC,GAcdC,CAASzH,EAAK/B,KACf,KCyCJ,SAASyJ,EAAc1H,EAAK/B,GAE3ByJ,EAAcd,gBACdc,EAAcd,cAAczI,eAAgB,GAGhDuJ,EAAcd,cAAgB5H,aAC1B,YApFR,SAAqBgB,EAAK/B,GAEtB,IAAK,IAAI/C,EAAI,EAAGA,EAAIkK,EAAiBlK,IAAK,CAEtC,IAAIuK,EAAQ,IAAIhG,IAAMtC,KAAKiG,SAAWnF,EAAQ0E,MAAOxF,KAAKiG,SAAWnF,EAAQgJ,QACzE3G,EAASnD,KAAKwK,MAAsB,GAAhBxK,KAAKiG,UAAiB+B,EAE1CyC,OAAG,EACP,GAAI3J,EAAQoC,OAAOwH,SAASpC,EAAOnF,GAC/BsH,EAAM5H,EAAI8H,qBACN7J,EAAQoC,OAAOX,EACfzB,EAAQoC,OAAOV,EACf,EACA8F,EAAM/F,EACN+F,EAAM9F,EACNW,OAED,CACH,IAAIyH,EAAQvH,YAAoBiF,EAAOxH,EAAQoC,QAC3C2H,EAAY7K,KAAK6D,IAAI+G,GAASzH,EAC9B2H,EAAY9K,KAAK+D,IAAI6G,GAASzH,EAElCsH,EAAM5H,EAAIkI,qBACNzC,EAAM/F,EAAIsI,EACVvC,EAAM9F,EAAIsI,EACVxC,EAAM/F,EAAIsI,EACVvC,EAAM9F,EAAIsI,GAIlBL,EAAIO,aAAa,EAAG,oBACpBP,EAAIO,aAAa,EAAG,iBAEpBnI,EAAIuF,UAAYqC,EAEhB5H,EAAI8D,YAEJ9D,EAAI0F,IACAD,EAAM/F,EACN+F,EAAM9F,EACNW,EAAQ,EAAGpD,KACf8C,EAAI2F,QA4CAyC,CAAYpI,EAAK/B,KAClB,KCvDJ,SAASoK,EAAarI,EAAK/B,GAE1BoK,EAAazB,gBACbyB,EAAazB,cAAczI,eAAgB,GAG/CkK,EAAazB,cAAgB5H,aACzB,WACIsG,EAAWtF,EAAK/B,KACjB,MCDJ,SAASqK,EAAetI,EAAK/B,GAE5BqK,EAAe1B,gBACf0B,EAAe1B,cAAczI,eAAgB,GAGjD,IAAIoK,EAAY1C,EAAO1I,KAAKwK,MAAMxK,KAAKiG,SAAWyC,EAAOnC,SAEzD4E,EAAe1B,cAAgB5H,aAC3B,YAtBR,SAAsBgB,EAAK/B,EAASsK,GAEhCvI,EAAIwI,YAAY,CAAC,EAAG,EAAI,EAAIrL,KAAKiG,WACjCpD,EAAIuF,UAAY,mBAChBvF,EAAIoH,YAAc,mBAClBpH,EAAIyI,SAAW,QACfzI,EAAI0I,UAAY,EAEhB7E,EAAS0E,EAAU1E,GAEnBD,YAAa5D,EAAK6D,EAAO2B,KAAI,SAAAxI,GAAC,OAAIA,EAAE+E,IAAI9D,EAAQoC,YAaxCsI,CAAa3I,EAAK/B,EAASsK,KAC5B,KC2BJ,SAAiCvI,EAAK/B,GAEzC,IAEI2K,EAAU,GACVC,EAAU,GAERC,EAAe3L,KAAKwK,MAAM1J,EAAQ0E,OAJjB,GAI2CkG,GAAW,GACvEE,EAAe5L,KAAKwK,MAAM1J,EAAQgJ,QALjB,GAK4C2B,GAAW,GAE9EC,EAAU5K,EAAQ0E,OAASmG,EAAe,GAPnB,GAQvBF,EAAU3K,EAAQgJ,QAAU8B,EAAe,GARpB,GAUvB/I,EAAIoH,YAAc,kBAElBpH,EAAIgH,UAAU,EAAG,EAAG/I,EAAQ0E,MAAO1E,EAAQgJ,QA7B/C,SAAsBjH,EAAK/B,EAAS+K,EAAMC,EAAMC,EAAQC,EAAQC,EAAUC,GAEtErJ,EAAI8D,YACJ,IAAK,IAAI5I,EAAI,EAAGA,EAAI8N,EAAM9N,IACtB,IAAK,IAAIoO,EAAI,EAAGA,EAAIL,EAAMK,IACtBtJ,EAAIsG,OACJtG,EAAIuJ,UAAUrO,GAAKgO,EAASG,GAAeC,GAAKH,EAASE,IACzD,IAAItD,EAAKqD,GAAUI,QAAQxJ,GAC3BA,EAAIyG,UAGZzG,EAAImE,SAmBJsF,CAAazJ,EAAK/B,EAAS6K,EAAcC,EAAcF,EAASD,EAd9C,GACK,MCpErBvI,EAAS,IAAIZ,IAAM,EAAG,GAE5BjC,OAAOE,iBAAiB,QAAQ,WAE5B,IAAI2E,EAASC,SAASoH,eAAe,aACjC1J,EAAMqC,EAAOG,WAAW,MAExBmH,EAAOrH,SAASsH,qBAAqB,QAAQ,GAE7C1L,EAAYwI,EAAWvJ,KAAKwK,MAAMxK,KAAKiG,SAAWsD,EAAWhD,SAEjE,SAASmG,IACLxH,EAAOM,MAAQnF,OAAOsM,WACtBzH,EAAO4E,OAASzJ,OAAOuM,YAEvB1J,EAAOX,EAAuB,GAAnBiK,EAAKK,YAChB3J,EAAOV,EAAwB,GAApBgK,EAAKM,aAEhB/L,EAAU8B,EAAK,CACXK,OAAQA,EACR4G,OAAQ5E,EAAO4E,OACftE,MAAON,EAAOM,QAItBkH,IAEArM,OAAOE,iBAAiB,mBAAmB,WACvCmM","file":"bg.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","export const FULL_PI = Math.PI * 2;\n\nexport function throttle(type, name, obj) {\n    obj = obj || window;\n    let running = false;\n    let func = () => {\n        if (running) {\n            return;\n        }\n        running = true;\n        requestAnimationFrame(() => {\n            obj.dispatchEvent(new CustomEvent(name));\n            running = false;\n        });\n    };\n    obj.addEventListener(type, func);\n}\n\nexport const REPEAT_COUNT_INVERSE = -1;\nexport const REPEAT_COUNT_INFINITY = -2;\n\nexport function animate(options) {\n\n    let animation = {\n        keepAnimating: true,\n    };\n\n    let start = performance.now();\n    requestAnimationFrame(function animate(time) {\n\n        let timeFraction = (time - start) / options.duration;\n        if (timeFraction > 1) timeFraction = 1;\n        if (timeFraction < 0) timeFraction = 0;\n\n        let progress = options.timing(timeFraction);\n\n        options.draw(progress);\n\n        if (animation.keepAnimating) {\n            if (timeFraction < 1) {\n                requestAnimationFrame(animate);\n            } else {\n                let restart = true;\n                if (options.repeatCount === REPEAT_COUNT_INVERSE) {\n                    let prevTiming = options.timing;\n                    options.timing = t => prevTiming(1 - t);\n                    options.repeatCount = 0;\n                } else if (options.repeatCount === REPEAT_COUNT_INFINITY) {\n\n                } else if (options.repeatCount > 0) {\n                    options.repeatCount--;\n                } else {\n                    restart = false;\n                }\n\n                if (restart) {\n                    start = performance.now();\n                    requestAnimationFrame(animate);\n                }\n            }\n        }\n    });\n\n    return animation;\n}\n\nexport function repeat(drawFunc, repeat) {\n    let animation = {\n        keepAnimating: true\n    };\n    let id = setInterval(() => {\n        if (!animation.keepAnimating) {\n            clearInterval(id);\n        } else {\n            requestAnimationFrame(drawFunc);\n        }\n    }, repeat);\n\n    return animation;\n}\n\nexport function animateBetween(a, b, u) {\n    return (1 - u) * a + u * b;\n}\n\nexport class Point {\n\n    constructor(x, y) {\n        this.x = parseFloat(x.toFixed(4));\n        this.y = parseFloat(y.toFixed(4));\n    }\n\n    connect(other, ctx) {\n        ctx.moveTo(this.x, this.y);\n        ctx.lineTo(other.x, other.y);\n    }\n\n    add(other) {\n        return new Point(this.x + other.x, this.y + other.y);\n    }\n\n    sub(other) {\n        return new Point(this.x - other.x, this.y - other.y);\n    }\n\n    dist(other) {\n        return Math.hypot(this.x - other.x, this.y - other.y);\n    }\n\n    len() {\n        return Math.hypot(this.x, this.y);\n    }\n\n    mult(k) {\n        return new Point(this.x * k, this.y * k);\n    }\n\n    div(k) {\n        return new Point(this.x / k, this.y / k);\n    }\n\n    isInside(center, radius) {\n        return this.dist(center) <= radius;\n    }\n}\n\nexport function angleBetweenTwoDots(first, second) {\n    return Math.atan2(second.y - first.y, second.x - first.x);\n}\n\nexport function toDegrees(rad) {\n    return rad * (180 / Math.PI);\n}\n\nexport function toRadians(angle) {\n    return angle * (Math.PI / 180);\n}\n\nexport function polarToX(r, theta) {\n    return r * Math.cos(theta);\n}\n\nexport function polarToY(r, theta) {\n    return r * Math.sin(theta);\n}\n\nexport function smallestRotateDirection(current, newAngle) {\n    let aR;\n    current = current || 0; // if rot undefined or 0, make 0, else rot\n    aR = current % 360;\n    if (aR < 0) {\n        aR += 360;\n    }\n    if (aR < 180 && (newAngle > (aR + 180))) {\n        current -= 360;\n    }\n    if (aR >= 180 && (newAngle <= (aR - 180))) {\n        current += 360;\n    }\n    current += (newAngle - aR);\n\n    return current;\n}\n\nexport function clampToRadius(center, actualPoint, radius) {\n    let offset = actualPoint.sub(center);\n    let distance = offset.len();\n\n    if (distance < radius) {\n        return actualPoint;\n    } else {\n        let direction = offset.div(distance);\n        return center.add(direction.mult(radius));\n    }\n}\n\nexport function clamp(val, min, max) {\n    if (val <= min) {\n        return min;\n    } else if (val >= max) {\n        return max;\n    } else {\n        return val;\n    }\n}\n\nexport function getTextSize(text, font) {\n    // re-use canvas object for better performance\n    let canvas = getTextSize.canvas || (getTextSize.canvas = document.createElement(\"canvas\"));\n    let context = canvas.getContext(\"2d\");\n    context.font = font;\n    let metrics = context.measureText(text);\n\n    return new Point(metrics.width, 32);\n}\n\nexport function createCirclePoints(radius, startAngle, amount) {\n    let step = FULL_PI / amount;\n    let currentAngle = startAngle;\n    let steps = [];\n    for (let i = 0; i < amount; i++) {\n        steps.push(new Point(polarToX(radius, currentAngle), polarToY(radius, currentAngle)));\n        currentAngle += step;\n    }\n\n    return steps;\n}\n\nexport function tweak(k) {\n    return k * (-1 + Math.random() * 2)\n}\n\nexport function getRnd(n, min, max) {\n    let res = [];\n    for (let i = 0; i < n; i++) {\n        res.push(min + Math.random() * (max - min));\n    }\n    return res\n}\n\nexport function getRndSign(n) {\n    let res = [];\n    for (let i = 0; i < n; i++) {\n        Math.random() >= 0.5 ? res.push(-1) : res.push(1);\n    }\n    return res\n}\n\n// bezier code from: https://stackoverflow.com/a/31169371/4142087\n\n// from: http://rosettacode.org/wiki/Evaluate_binomial_coefficients#JavaScript\nexport function binom(n, k) {\n    let coeff = 1;\n    for (let i = n - k + 1; i <= n; i++) coeff *= i;\n    for (let i = 1; i <= k; i++) coeff /= i;\n    return coeff;\n}\n\n// based on: https://stackoverflow.com/questions/16227300\nexport function bezier(t, plist) {\n    let order = plist.length - 1;\n\n    let y = 0;\n    let x = 0;\n\n    for (let i = 0; i <= order; i++) {\n        x = x + (binom(order, i) * Math.pow((1 - t), (order - i)) * Math.pow(t, i) * (plist[i].x));\n        y = y + (binom(order, i) * Math.pow((1 - t), (order - i)) * Math.pow(t, i) * (plist[i].y));\n    }\n\n    return {x, y};\n}\n\n// based on incovergent impl, but I think he took it from stackoverflow (I saw it there :) )\nexport function drawAsSpline(ctx, points) {\n    ctx.beginPath();\n    ctx.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length - 2; i++) {\n        let xm = (points[i].x + points[i + 1].x) / 2\n            , ym = (points[i].y + points[i + 1].y) / 2;\n        ctx.quadraticCurveTo(points[i].x, points[i].y, xm, ym);\n    }\n    let end = points.length - 2;\n    ctx.quadraticCurveTo(points[end].x, points[end].y, points[end + 1].x, points[end + 1].y);\n    ctx.stroke();\n}","import {animate, animateBetween, polarToX, polarToY, REPEAT_COUNT_INFINITY} from \"../utils/utils\";\n\nlet MAX_RADIUS_WAVES = 0;\nlet INIT_RADIUS_WAVES = 0;\nconst WAVE_GAP = 100;\nconst WAVE_AMPLITUDE = 30;\n\nfunction drawCircleWaves(ctx, options, waveOffset) {\n    ctx.clearRect(0, 0, options.width, options.height);\n\n    let currentRadius = INIT_RADIUS_WAVES + waveOffset;\n\n    while (currentRadius < MAX_RADIUS_WAVES) {\n\n        let distanceFromCenter = currentRadius / MAX_RADIUS_WAVES;\n\n        ctx.strokeStyle = 'rgba(0,0,0,' + distanceFromCenter + ')';\n\n        drawWave(ctx, currentRadius, options.center, WAVE_AMPLITUDE * distanceFromCenter);\n\n        currentRadius += WAVE_GAP;\n    }\n}\n\nfunction calculateWaveR(offset, theta, nodeCount, amplitude) {\n    return offset + amplitude * Math.sin(nodeCount * theta);\n}\n\nfunction drawWave(ctx, radius, offsetPoint, amplitude) {\n    let increase = Math.PI / (180 * 1);\n\n    let counter = 0;\n    let x = polarToX(calculateWaveR(radius, counter, 10, amplitude), counter) + offsetPoint.x;\n    let y = polarToY(calculateWaveR(radius, counter, 10, amplitude), counter) + offsetPoint.y;\n\n    ctx.beginPath();\n    while (counter < 2 * Math.PI) {\n\n        ctx.moveTo(x, y);\n\n        x = polarToX(calculateWaveR(radius, counter, 10, amplitude), counter) + offsetPoint.x;\n        y = polarToY(calculateWaveR(radius, counter, 10, amplitude), counter) + offsetPoint.y;\n\n        counter += increase;\n\n        ctx.lineTo(x, y);\n    }\n    ctx.stroke();\n}\n\nexport function launchWaves(ctx, options) {\n\n    let radius = options.center.len();\n\n    MAX_RADIUS_WAVES = radius;\n    INIT_RADIUS_WAVES = radius / WAVE_GAP;\n\n    if (launchWaves.lastAnimation) {\n        launchWaves.lastAnimation.keepAnimating = false;\n    }\n    launchWaves.lastAnimation = animate({\n        duration: 5000.0,\n        timing: t => animateBetween(0, WAVE_GAP, Math.abs(t)),\n        draw: fraction => {\n            drawCircleWaves(ctx, options, fraction);\n        },\n        repeatCount: REPEAT_COUNT_INFINITY,\n    });\n}\n\n","import {FULL_PI, polarToX, polarToY, repeat} from \"../utils/utils\";\n\nlet SAND_RADIUS = 0;\nconst ANGLE_STEP = Math.PI / (180 * 4);\nconst STEP_AMOUNT = 100;\n\nlet prevDelta = 0;\nlet prevAngle = 0;\n\nfunction drawSand(ctx, options) {\n\n    ctx.fillStyle = \"rgba(0,0,0,0.05)\";\n\n    for (let i = 0; i < STEP_AMOUNT; i++) {\n        ctx.beginPath();\n\n        prevDelta = prevDelta + (-1 + Math.random() * 2);\n\n        let newR = SAND_RADIUS + prevDelta;\n\n        ctx.arc(\n            options.center.x + polarToX(newR, prevAngle),\n            options.center.y + polarToY(newR, prevAngle),\n            1, 0, FULL_PI);\n        ctx.fill();\n\n        prevAngle += (1 / newR);\n    }\n}\n\nexport function launchSand(ctx, options) {\n\n    SAND_RADIUS = Math.min(options.height, options.width) * 0.4;\n\n    if (launchSand.lastAnimation) {\n        launchSand.lastAnimation.keepAnimating = false;\n    }\n\n    launchSand.lastAnimation = repeat(\n        () => {\n            drawSand(ctx, options);\n        }, 16\n    );\n}\n","import {angleBetweenTwoDots, FULL_PI, Point, repeat} from \"../utils/utils\";\n\nconst CIRCLE_RADIUS = 5;\nconst CIRCLES_BY_STEP = 1;\n\nfunction drawCircles(ctx, options) {\n\n    for (let i = 0; i < CIRCLES_BY_STEP; i++) {\n\n        let point = new Point(Math.random() * options.width, Math.random() * options.height);\n        let radius = Math.floor(Math.random() * 50) + CIRCLE_RADIUS;\n\n        let grd;\n        if (options.center.isInside(point, radius)) {\n            grd = ctx.createRadialGradient(\n                options.center.x,\n                options.center.y,\n                1,\n                point.x,\n                point.y,\n                radius\n            );\n        } else {\n            let alpha = angleBetweenTwoDots(point, options.center);\n            let cosAlphaR = Math.cos(alpha) * radius;\n            let sinAlphaR = Math.sin(alpha) * radius;\n\n            grd = ctx.createLinearGradient(\n                point.x + cosAlphaR,\n                point.y + sinAlphaR,\n                point.x - cosAlphaR,\n                point.y - sinAlphaR\n            );\n        }\n\n        grd.addColorStop(0, 'rgba(0,0,0,0.05)');\n        grd.addColorStop(1, 'rgba(0,0,0,0)');\n\n        ctx.fillStyle = grd;\n\n        ctx.beginPath();\n\n        ctx.arc(\n            point.x,\n            point.y,\n            radius, 0, FULL_PI);\n        ctx.fill();\n    }\n}\n\n// todo: improve\nfunction drawCirclesV2(ctx, options) {\n\n    for (let i = 0; i < CIRCLES_BY_STEP; i++) {\n\n        let point = new Point(Math.random() * options.width, Math.random() * options.height);\n        let radius = Math.floor(Math.random() * 50) + CIRCLE_RADIUS;\n\n        let grd = ctx.createRadialGradient(\n            options.center.x,\n            options.center.y,\n            1,\n            options.center.x,\n            options.center.y,\n            options.center.len()\n        );\n\n        grd.addColorStop(0, 'rgba(0,0,0,0.05)');\n        grd.addColorStop(1, 'rgba(0,0,0,0)');\n\n        ctx.fillStyle = grd;\n\n        ctx.beginPath();\n\n        ctx.arc(\n            point.x,\n            point.y,\n            radius, 0, FULL_PI);\n        ctx.fill();\n    }\n}\n\nexport function launchCircles(ctx, options) {\n\n    if (launchCircles.lastAnimation) {\n        launchCircles.lastAnimation.keepAnimating = false;\n    }\n\n    launchCircles.lastAnimation = repeat(\n        () => {\n            drawCircles(ctx, options);\n        }, 25\n    );\n}\n\n","import {bezier, createCirclePoints, FULL_PI, Point, repeat, tweak} from \"../utils/utils\";\n\nconst RADIUS = 200;\nconst POINTS_AMOUNT = Math.random() * 30 + 50;//25;\n\n// simple\nfunction randomTweaksV1(points) {\n    return points.map(p => p.add(\n        new Point(\n            tweak(20),\n            tweak(20)\n        )));\n}\n\nlet points = createCirclePoints(RADIUS, Math.random() * FULL_PI, POINTS_AMOUNT);\n\nfunction drawBezier(ctx, options) {\n\n    ctx.fillStyle = \"rgba(0,0,0,0.05)\";\n\n    points = randomTweaksV1(points);\n\n    for (let i = 0; i < 1; i += (Math.random() * 0.006 + 0.001)) {\n\n        ctx.beginPath();\n\n        let point = bezier(i, points);\n\n        ctx.arc(\n            options.center.x + point.x,\n            options.center.y + point.y,\n            1, 0, FULL_PI);\n        ctx.fill();\n    }\n}\n\nexport function launchBezier(ctx, options) {\n\n    if (launchBezier.lastAnimation) {\n        launchBezier.lastAnimation.keepAnimating = false;\n    }\n\n    launchBezier.lastAnimation = repeat(\n        () => {\n            drawBezier(ctx, options);\n        }, 100\n    );\n}\n\n","import {createCirclePoints, drawAsSpline, FULL_PI, Point, repeat, tweak} from \"../utils/utils\";\n\nconst RADIUS = 200;\nconst POINTS_AMOUNT = Math.random() * 30 + 25;\n\n// simple\nfunction randomTweaksV2V1(points) {\n    return points.map(p => p.add(\n        new Point(\n            tweak(3),\n            tweak(3)\n        )));\n}\n\n// idx matters\nfunction randomTweaksV2V2(points) {\n    // not now, invent something better later\n    return randomTweaksV2V1(points);\n    // return points.map(function (p, idx, arr) {\n    //     return p.add(\n    //         new Point(\n    //             tweak(5 * idx / arr.length),\n    //             tweak(5 * idx / arr.length)\n    //         ));\n    // });\n}\n\nconst tweaks = [randomTweaksV2V1, randomTweaksV2V2];\n\nlet points = createCirclePoints(RADIUS, Math.random() * FULL_PI, POINTS_AMOUNT);\n\nfunction drawBezierV2(ctx, options, tweakFunc) {\n\n    ctx.setLineDash([1, 1 + 6 * Math.random()]);\n    ctx.fillStyle = \"rgba(0,0,0,0.05)\";\n    ctx.strokeStyle = \"rgba(0,0,0,0.05)\";\n    ctx.lineJoin = \"round\";\n    ctx.lineWidth = 1;\n\n    points = tweakFunc(points);\n\n    drawAsSpline(ctx, points.map(p => p.add(options.center)));\n}\n\nexport function launchBezierV2(ctx, options) {\n\n    if (launchBezierV2.lastAnimation) {\n        launchBezierV2.lastAnimation.keepAnimating = false;\n    }\n\n    let tweakFunc = tweaks[Math.floor(Math.random() * tweaks.length)];\n\n    launchBezierV2.lastAnimation = repeat(\n        () => {\n            drawBezierV2(ctx, options, tweakFunc);\n        }, 16\n    );\n}\n\n","// list for connections between nodes\nimport {Point} from \"../utils/utils\";\n\nconst connections = [[0, 1], [0, 3],\n    [1, 2], [1, 3], [1, 4],\n    [2, 4], [2, 6],\n    [3, 4], [3, 5],\n    [4, 5], [4, 6],\n    [5, 6], [5, 7],\n    [6, 7], [6, 8],\n    [7, 8]];\n\n\nclass Grid {\n    constructor(size) {\n\n        this.nodes = [];\n        this.mirrornodes = [];\n\n        // create the nodes in the grid\n        this.nodes.push(new Point(0, 0));\n        this.nodes.push(new Point(0, -size));\n        this.nodes.push(new Point(0, -2 * size));\n        this.nodes.push(new Point(size / 2.0, -size / 2.0));\n        this.nodes.push(new Point(0.5 * size, -1.5 * size));\n        this.nodes.push(new Point(size, -size));\n        this.nodes.push(new Point(size, -2 * size));\n        this.nodes.push(new Point(1.5 * size, -1.5 * size));\n        this.nodes.push(new Point(2 * size, -2 * size));\n\n        // create the nodes which mirror over the diagonal line\n        this.mirrornodes.push(new Point(0, 0));\n        this.mirrornodes.push(new Point(size, 0));\n        this.mirrornodes.push(new Point(2 * size, 0));\n        this.mirrornodes.push(new Point(size / 2.0, -size / 2.0));\n        this.mirrornodes.push(new Point(1.5 * size, -0.5 * size));\n        this.mirrornodes.push(new Point(size, -size));\n        this.mirrornodes.push(new Point(2 * size, -size));\n        this.mirrornodes.push(new Point(1.5 * size, -1.5 * size));\n        this.mirrornodes.push(new Point(2 * size, -2 * size));\n\n        // randomly choose which nodes are connecting\n        this.connectChoices = new Array(16);\n        for (let i = 0; i < this.connectChoices.length; i++) {\n            this.connectChoices[i] = Math.random() >= 0.5;\n        }\n    }\n\n    connectDraw(ctx) {\n        for (let i = 0; i < this.connectChoices.length; i++) {\n            if (this.connectChoices[i]) {\n                this.nodes[connections[i][0]].connect(this.nodes[connections[i][1]], ctx);\n                this.mirrornodes[connections[i][0]].connect(this.mirrornodes[connections[i][1]], ctx);\n            }\n        }\n    }\n\n    display(ctx) {\n\n        for (let i = 0; i < 4; i++) {\n            ctx.save();\n            ctx.rotate((Math.PI / 2) * i);\n            this.connectDraw(ctx);\n            ctx.restore();\n        }\n    }\n}\n\nfunction drawSymmetry(ctx, options, fitX, fitY, spaceX, spaceY, gridSize, fullGridSize) {\n\n    ctx.beginPath();\n    for (let i = 0; i < fitX; i++) {\n        for (let j = 0; j < fitY; j++) {\n            ctx.save();\n            ctx.translate(i * (spaceX + fullGridSize), j * (spaceY + fullGridSize));\n            new Grid(gridSize).display(ctx);\n            ctx.restore();\n        }\n    }\n    ctx.stroke();\n}\n\nexport function launchRandomSymmetryArt(ctx, options) {\n\n    const GRID_SIZE = 10;\n    const FULL_GRID_SIZE = 3 * GRID_SIZE;\n    let SPACE_Y = 50;\n    let SPACE_X = 50;\n\n    const FIT_AMOUNT_X = Math.floor(options.width / (FULL_GRID_SIZE + SPACE_X) + 1);\n    const FIT_AMOUNT_Y = Math.floor(options.height / (FULL_GRID_SIZE + SPACE_Y) + 1);\n\n    SPACE_X = options.width / (FIT_AMOUNT_X - 1) - FULL_GRID_SIZE;\n    SPACE_Y = options.height / (FIT_AMOUNT_Y - 1) - FULL_GRID_SIZE;\n\n    ctx.strokeStyle = 'rgba(0,0,0,0.5)';\n\n    ctx.clearRect(0, 0, options.width, options.height);\n    drawSymmetry(ctx, options, FIT_AMOUNT_X, FIT_AMOUNT_Y, SPACE_X, SPACE_Y, GRID_SIZE, FULL_GRID_SIZE);\n}","import {Point} from \"./utils/utils\";\nimport {launchWaves} from \"./drawings/waves\";\nimport {launchSand} from \"./drawings/sand\";\nimport {launchCircles} from \"./drawings/circles\";\nimport {launchBezier} from \"./drawings/bezier_jokes\";\nimport {launchBezierV2} from \"./drawings/bezier_jokes_v2\";\nimport {launchRandomSymmetryArt} from \"./drawings/random_symmetry\";\n\nconst animations = [\n    launchWaves, // credits to https://medium.com/s23nyc-tech/geometric-android-animations-using-the-canvas-dd687c43f3f4\n    launchSand, // credits to incovergent\n    launchCircles,\n    launchBezier,\n    launchBezierV2, // credits to incovergent\n    launchRandomSymmetryArt // credits to atticusbones\n];\n\nconst center = new Point(0, 0);\n\nwindow.addEventListener('load', () => {\n\n    let canvas = document.getElementById('bg-canvas');\n    let ctx = canvas.getContext('2d');\n\n    let body = document.getElementsByTagName('body')[0];\n\n    let animation = animations[Math.floor(Math.random() * animations.length)];\n\n    function resizeCanvas() {\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n\n        center.x = body.clientWidth * 0.5;\n        center.y = body.clientHeight * 0.5;\n\n        animation(ctx, {\n            center: center,\n            height: canvas.height,\n            width: canvas.width\n        });\n    }\n\n    resizeCanvas();\n\n    window.addEventListener('optimizedResize', () => {\n        resizeCanvas();\n    });\n});\n\n"],"sourceRoot":""}